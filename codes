1. Matrix
2. Check Well Parenthsis
3. Job Creation Using Queue
4. Linear And Sentinal Search Binary & Fibbonacci
5. Quick Sort
6. SET Operations Icecream
7. String Operations
8. In a second year computer engineering class, group A students play cricket, group B students play
9.  Write a python program to store marks stored in subject "Fundamentals of
Data Structure" by
10. Pallindrome selection and bubble sort
11. Pallindrome
12. Pizza Parlour
13. A double-ended queue (deque)
14. Pinnacle club



#Matrix

def input_matrix_index_wise(rows, cols, name):
    matrix = [[0] * cols for _ in range(rows)]
    print(f"Enter the elements for matrix {name} ({rows}x{cols}):")
    for i in range(rows):
        for j in range(cols):
            while True:
                try:
                    value = float(input(f"Enter element at position ({i+1},{j+1}): "))
                    matrix[i][j] = value
                    break
                except ValueError:
                    print("Invalid input. Please enter a numeric value.")
    return matrix

rows = 3
cols = 3

x = input_matrix_index_wise(rows, cols, 'x')
y = input_matrix_index_wise(rows, cols, 'y')

result = [[0 for _ in range(cols)] for _ in range(rows)]

print("\nMatrix x:")
for row in x:
    print(row)

print("\nMatrix y:")
for row in y:
    print(row)

print("\nMatrix result:")
for row in result:
    print(row)

print("1. Addition")
print("2. Substraction")
print("3. Multiplication")
print("4. Transpose")
a= int(input("Enter the number (Option) "))

if a ==1:
    # Addition
    print("Addition Of the Matrix is ")
    for i in range(len(x)):
        for j in range(len(x[0])):
            result[i][j] = x[i][j] + y[i][j]
    for r in result:
        print(r)

elif a==2:
    # Subtraction
    print("Substraction Of the Matrix is ")
    for i in range(len(x)):
        for j in range(len(x[0])):
            result[i][j] = x[i][j] - y[i][j]
    for r in result:
        print(r)

elif a == 3:
    print("Multiplication Of the matrix is ")
    for i in range(len(x)):
        for j in range(len(y[0])):
            for k in range(len(y)):
                result[i][j] += x[i][k] + y[k][j]
    for r in result:
        print(r)

elif a ==4:
    #Transpose
    print("Enter the Matrix you want to do matrix of")
    mat = input("Enter the matrix name (x, y) in lowercase")
    if mat == x:
        print ("Transpose of the Matrix is x")
        for i in range(len(x)):
            for j in range(len(x[0])):
                result[j][i] = x[i][j] 
        for r in result:
            print(r)

    elif mat == y:
        print ("Transpose of the Matrix is y ")
        for i in range(len(y)):
            for j in range(len(y[0])):
                result[j][i] = y[i][j] 
        for r in result:
            print(r)

else :
    print("Invalid Value")





#Check Well Parenthsis


#include <iostream>
using namespace std;
#define size 10

class stackexp {
    int top;
    char stk[size];

public:
    stackexp() {
        top = -1;
    }
    void push(char);
    char pop();
    int isfull();
    int isempty();
};

void stackexp::push(char x) {
    top = top + 1;
    stk[top] = x;
}

char stackexp::pop() {
    char s;
    s = stk[top];
    top = top - 1;
    return s;
}

int stackexp::isfull() {
    if (top == size)
        return 1;
    else
        return 0;
}

int stackexp::isempty() {
    if (top == -1)
        return 1;
    else
        return 0;
}

int main() {
    stackexp s1;
    char exp[20], ch;
    int i = 0;
    cout << "\n\t!! Parenthesis Checker..!!!!" << endl;
    cout << "\nEnter the expression to check whether it is in well form or not: ";
    cin >> exp;

    if ((exp[0] == ')') || (exp[0] == ']') || (exp[0] == '}')) {
        cout << "\nInvalid Expression.....\n";
        return 0;
    } else {
        while (exp[i] != '\0') {
            ch = exp[i];
            switch (ch) {
                case '(':
                    s1.push(ch);
                    break;
                case '[':
                    s1.push(ch);
                    break;
                case '{':
                    s1.push(ch);
                    break;
                case ')':
                    s1.pop();
                    break;
                case ']':
                    s1.pop();
                    break;
                case '}':
                    s1.pop();
                    break;
            }
            i = i + 1;
        }
    }

    if (s1.isempty()) {
        cout << "\nExpression is well parenthesized...\n";
    } else {
        cout << "\nSorry!!! Invalid Expression or not well parenthesized...\n";
    }
    return 0;
}




# Job Creation Using Queue

#include <iostream>
#define MAX 10
using namespace std;

struct queue {
    int data[MAX];
    int front, rear;
};

class Queue {
    struct queue q;

public:
    Queue() { q.front = q.rear = -1; }
    int isempty();
    int isfull();
    void enqueue(int);
    int delqueue();
    void display();
};

int Queue::isempty() {
    return (q.front == q.rear) ? 1 : 0;
}

int Queue::isfull() {
    return (q.rear == MAX - 1) ? 1 : 0;
}

void Queue::enqueue(int x) {
    q.data[++q.rear] = x;
}

int Queue::delqueue() {
    return q.data[++q.front];
}

void Queue::display() {
    int i;
    cout << "\n";
    for (i = q.front + 1; i <= q.rear; i++)
        cout << q.data[i] << " ";
}

int main() {
    Queue obj;
    int ch, x;

    do {
        cout << "\n 1. Insert Job\n 2. Delete Job\n 3. Display\n 4. Exit\n Enter your choice: ";
        cin >> ch;

        switch (ch) {
            case 1:
                if (!obj.isfull()) {
                    cout << "\n Enter data: \n";
                    cin >> x;
                    obj.enqueue(x);
                    cout << endl;
                } else {
                    cout << "Queue is overflow!!!\n\n";
                }
                break;

            case 2:
                if (!obj.isempty()) {
                    cout << "\n Deleted Element = " << obj.delqueue() << endl;
                } else {
                    cout << "\n Queue is underflow!!!\n\n";
                }
                cout << "\nRemaining Jobs: \n";
                obj.display();
                break;

            case 3:
                if (!obj.isempty()) {
                    cout << "\n Queue contains: \n";
                    obj.display();
                } else {
                    cout << "\n Queue is empty!!!\n\n";
                }
                break;

            case 4:
                cout << "\n Exiting Program.....";
                break;
        }
    } while (ch != 4);

    return 0;
}



##Linear And Sentinal Search 

#WAP to store roll nos in array and search using linear and sentinel search
from array import *

#Creating array
a = array('i',[])
n = int(input("Enter no of students: "))
for i in range(n):
    a.append(int(input("Enter roll no: ")))

#Linear Search
def linear(l,ele):
     if ele in l:
         for i in l:
             if i == ele:
                 return l.index(i)
                 break

#Sentinel Search
def sentinel(l,ele):
    last = l[-1]
    l[-1] = ele
    i = 0
    while l[i] != ele:
        i += 1
    l[-1] = last
    if (i < len(l)-1) or l[-1] == ele:
        return i
    else:
        return None

key = int(input("Enter key: "))

decider = True
while decider:
    ch = int(input("1. Linear search\n2. Sentinel Search\n3. Exit\n"))
    match ch:
        case 1:
            print("Index of",key,":",linear(a,key))
        case 2:
            print("Index of",key,":",sentinel(a,key))
        case 3:
            decider = False



##Binary & Fibbonacci

# Function to perform Binary Search
def binary_search(arr, x):
    low = 0
    high = len(arr) - 1

    while low <= high:
        mid = (high + low) // 2

        # If x is greater, ignore the left half
        if arr[mid] < x:
            low = mid + 1
        # If x is smaller, ignore the right half
        elif arr[mid] > x:
            high = mid - 1
        # x is present at mid
        else:
            return True
    return False

# Function to perform Fibonacci Search
def fibonacci_search(arr, x):
    n = len(arr)
    fibM2 = 0  # (m-2)'th Fibonacci number
    fibM1 = 1  # (m-1)'th Fibonacci number
    fibM = fibM2 + fibM1  # m'th Fibonacci number

    # fibM is the smallest Fibonacci number greater than or equal to n
    while fibM < n:
        fibM2 = fibM1
        fibM1 = fibM
        fibM = fibM2 + fibM1

    offset = -1

    while fibM > 1:
        i = min(offset + fibM2, n - 1)  # Ensure i is within bounds

        if arr[i] < x:
            fibM = fibM1
            fibM1 = fibM2
            fibM2 = fibM - fibM1
            offset = i
        elif arr[i] > x:
            fibM = fibM2
            fibM1 = fibM1 - fibM2
            fibM2 = fibM - fibM1
        else:
            return True

    if fibM1 and offset + 1 < n and arr[offset + 1] == x:
        return True
    return False

# Main logic
try:
    # Input sorted list of roll numbers
    roll_numbers = list(map(int, input("Enter list of roll numbers (comma-separated): ").split(',')))
    roll_numbers.sort()  # Ensure the list is sorted

    # Input roll number to search
    roll_no = int(input("Enter roll number to search: "))

    # Binary Search
    if binary_search(roll_numbers, roll_no):
        print(f"Student with roll number {roll_no} attended the training (Binary Search).")
    else:
        print(f"Student with roll number {roll_no} did not attend the training (Binary Search).")

    # Fibonacci Search
    if fibonacci_search(roll_numbers, roll_no):
        print(f"Student with roll number {roll_no} attended the training (Fibonacci Search).")
    else:
        print(f"Student with roll number {roll_no} did not attend the training (Fibonacci Search).")
except ValueError:
    print("Invalid input! Please enter valid roll numbers and a valid roll number to search.")



##Quick Sort


### python 



# Function to partition the array
def partition(array, low, high):
    pivot = array[high]
    i = low - 1
    for j in range(low, high):
        if array[j] <= pivot:
            i += 1
            array[i], array[j] = array[j], array[i]
    array[i + 1], array[high] = array[high], array[i + 1]
    return i + 1

# Function to perform QuickSort
def quicksort(array, low=0, high=None):
    if high is None:
        high = len(array) - 1
    if low < high:
        pivot_index = partition(array, low, high)
        quicksort(array, low, pivot_index - 1)
        quicksort(array, pivot_index + 1, high)

# Driver code
my_array = [64, 34, 25, 12, 22, 11, 90, 5]
quicksort(my_array)
print("Sorted array:", my_array)





#### C++

#include <iostream>
using namespace std;

// Function to swap two elements
void swap(int* a, int* b) {
    int t = *a;
    *a = *b;
    *b = t;
}

// Partitioning the array and returning the pivot index
int partition(int arr[], int low, int high) {
    int pivot = arr[high]; // Choosing the last element as the pivot
    int i = (low - 1);     // Index of smaller element

    for (int j = low; j <= high - 1; j++) {
        // If the current element is smaller than or equal to the pivot
        if (arr[j] <= pivot) {
            i++; // Increment index of smaller element
            swap(&arr[i], &arr[j]);
        }
    }

    swap(&arr[i + 1], &arr[high]);
    return (i + 1);
}

// The main function that implements QuickSort
void quickSort(int arr[], int low, int high) {
    if (low < high) {
        // pi is partitioning index, arr[pi] is now at the right place
        int pi = partition(arr, low, high);

        // Separately sort elements before partition and after partition
        quickSort(arr, low, pi - 1);
        quickSort(arr, pi + 1, high);
    }
}

// Function to print an array
void printArray(int arr[], int size) {
    for (int i = 0; i < size; i++)
        cout << arr[i] << " ";
    cout << endl;
}

// Driver code
int main() {
    int arr[] = {64, 25, 12, 22, 11};
    int n = sizeof(arr) / sizeof(arr[0]);

    cout << "Original array: " << endl;
    printArray(arr, n);

    quickSort(arr, 0, n - 1);

    cout << "Sorted array: " << endl;
    printArray(arr, n);

    return 0;
}





## SET Operations Icecream


/*SE Comp Engg class set of A students like vanilla ice cream, set of B student like butterscotch. Write CPP Program to store two sets using linked list. Calculate:
1. set of students who like both 
2. set of students who like either vanilla or butterscotch 
3. No. of students who like neither vanilla nor butterscotch*/

#include <iostream>
using namespace std;

class IceCream{
public:
	struct node{
		int data;
		node* next;
	}*head,*temp;
	int len;
	IceCream(){
		head = NULL;
		len = 0;
	}
	
	node* create(){
		int item;
		cout << "Enter Roll No: ";
		cin >> item;
		node *temp = new (struct node);
		temp -> data = item;
		temp -> next = NULL;
		return temp;
	}
	
	void InsertNode(){
		node* temp = create();
		if (head == NULL){
			head = temp;
		} else {
			node* ptr = head;
			while (ptr->next != NULL){
				ptr = ptr->next;
			}
			ptr->next = temp;
		}
		
	}
	
	void DeleteNode(){
		if (head == NULL){
			cout << "Empty List";
		}else if (head->next == NULL) {
			delete head;  
			head = NULL;
		} else {
			node* ptr = NULL;
			node* ptr1 = head;
			while (ptr1->next != NULL){
				ptr = ptr1;
				ptr1 = ptr1->next;
			}
			ptr->next = NULL;
			delete ptr1;
		}
	}
	
	void Display(){
		node* ptr = head;
		while (ptr != NULL){
			cout << ptr->data << " -> ";
			ptr = ptr->next;
		}
		cout << "NULL" << endl;
	}
	
	void findIntersection(node* listB) {
		cout << "Students who like both (Intersection): ";
		node* ptrA = head;
		while (ptrA != NULL) {
			node* ptrB = listB;
			while (ptrB != NULL) {
				if (ptrA->data == ptrB->data) {
				cout << ptrA->data << " ";
				break;
				}
			ptrB = ptrB->next;
			}
		ptrA = ptrA->next;
		}
		cout << endl;
	}
	
	void findUnion(node* listB) {
		cout << "Students who like either (Union): ";
		node* ptrA = head;
		while (ptrA != NULL) {
			cout << ptrA->data << " ";
			ptrA = ptrA->next;
		}
		node* ptrB = listB;
		while (ptrB != NULL) {
			bool found = false;
			ptrA = head;
			while (ptrA != NULL) {
				if (ptrB->data == ptrA->data) {
					found = true;
					break;
				}
				ptrA = ptrA->next;
			}
			if (!found) {
				cout << ptrB->data << " ";
			}
			ptrB = ptrB->next;
		}
		cout << endl;
	}
	
	int countNeither(int totalStudents) {
		int count = 0;
		node* ptrA = head;
		node* ptrB = head; 
		while (totalStudents-- > 0) {
			bool foundA = false, foundB = false;
			ptrA = head;
			ptrB = head; 
			while (ptrA != NULL) {
				if (ptrA->data == totalStudents) {
					foundA = true;
					break;
				}
				ptrA = ptrA->next;
			}
			while (ptrB != NULL) {
				if (ptrB->data == totalStudents) {
					foundB = true;
					break;
				}
				ptrB = ptrB->next;
			}
			if (!foundA && !foundB) {
				count++;
			}
		}
		return count;
	}
		
};

int main() {
	IceCream vanilla, butterscotch;

	cout << "Enter students who like Vanilla Ice Cream (5 students):" << endl;
	for (int j = 0; j < 5; j++) {
		vanilla.InsertNode();
	}
	vanilla.Display();

	cout << "Enter students who like Butterscotch Ice Cream (5 students):" << endl;
	for (int j = 0; j < 5; j++) {
		butterscotch.InsertNode();
	}
	butterscotch.Display();

	vanilla.findIntersection(butterscotch.head);
	vanilla.findUnion(butterscotch.head);
    
	int totalStudents = 10; 
	int neitherCount = vanilla.countNeither(totalStudents);
	cout << "Number of students who like neither flavor: " << neitherCount << endl;

	return 0;
}
	
	
	
	
	
	
##String Operations 


def longest_word(s):
    words = s.split()
    if words:
        longest = max(words, key=len)
        return longest
    return ""

def char_frequency(s, char):
    return s.count(char)

def is_palindrome(s):
    s = s.lower().replace(" ", "")
    return s == s[::-1]

def first_appearance_index(s, substring):
    index = s.find(substring)
    return index if index != -1 else "Substring not found"

def word_occurrences(s):
    from collections import Counter
    words = s.split()
    word_count = Counter(words)
    return dict(word_count)

def main():
    sample_string = input("Enter the string: ")

    while True:
        print("\nSelect an operation:")
        print("1. Display the word with the longest length")
        print("2. Determine the frequency of occurrence of a particular character")
        print("3. Check whether the string is a palindrome")
        print("4. Display index of the first appearance of a substring")
        print("5. Count the occurrences of each word in the string")
        print("6. Exit")

        choice = input("Enter your choice (1-6): ")

        if choice == '1':
            print("Longest word:", longest_word(sample_string))

        elif choice == '2':
            char = input("Enter the character to find its frequency: ")
            if len(char) != 1:
                print("Please enter exactly one character.")
            else:
                print(f"Frequency of character '{char}':", char_frequency(sample_string, char))

        elif choice == '3':
            print("Is the string a palindrome?", is_palindrome(sample_string))

        elif choice == '4':
            substring = input("Enter the substring to find its first appearance index: ")
            print(f"First appearance of substring '{substring}':", first_appearance_index(sample_string, substring))

        elif choice == '5':
            print("Word occurrences:", word_occurrences(sample_string))

        elif choice == '6':
            print("Exiting...")
            break

        else:
            print("Invalid choice. Please enter a number between 1 and 6.")

if __name__ == "__main__":
    main()




##Experiment No. 1 : In a second year computer engineering class, group A students play cricket, group
B students play
badminton and group C students play football.
Write a python program using functions to compute following:
a) List of students who play both cricket and badminton.
b) List of students who play either cricket or badminton but not both.
c) Number of students who play neither cricket nor badminton.
d) Number of students who play cricket and football but not badminton.
(NOTE : While realising the group, duplicate entries should be avoided. Do not use SET built-in
functions)
# Function for removing duplicate entries from the group



# Function to remove duplicate entries from a list
def remove_duplicate(lst):
    unique_list = []
    for item in lst:
        if item not in unique_list:
            unique_list.append(item)
    return unique_list

# Function to compute intersection of two lists
def intersection(lst1, lst2):
    return [item for item in lst1 if item in lst2]

# Function to compute union of two lists
def union(lst1, lst2):
    result = lst1.copy()
    for item in lst2:
        if item not in result:
            result.append(item)
    return result

# Function to compute difference between two lists (lst1 - lst2)
def difference(lst1, lst2):
    return [item for item in lst1 if item not in lst2]

# Function to compute symmetric difference between two lists
def symmetric_difference(lst1, lst2):
    return union(difference(lst1, lst2), difference(lst2, lst1))

# Function for List of students who play both cricket and badminton
def cricket_and_badminton(cricket, badminton):
    result = intersection(cricket, badminton)
    print("\nList of students who play both cricket and badminton:", result)
    return len(result)

# Function for List of students who play either cricket or badminton but not both
def either_cricket_or_badminton(cricket, badminton):
    result = symmetric_difference(cricket, badminton)
    print("\nList of students who play either cricket or badminton but not both:", result)
    return len(result)

# Function for Number of students who play neither cricket nor badminton
def neither_cricket_nor_badminton(all_students, cricket, badminton):
    result = difference(all_students, union(cricket, badminton))
    print("\nList of students who play neither cricket nor badminton:", result)
    return len(result)

# Function for Number of students who play cricket and football but not badminton
def cricket_and_football_not_badminton(cricket, football, badminton):
    result = difference(intersection(cricket, football), badminton)
    print("\nList of students who play cricket and football but not badminton:", result)
    return len(result)

# Main function
def main():
    # Input for all students
    n = int(input("Enter the number of students in SE Comp: "))
    all_students = [input(f"Enter name of student {i+1}: ") for i in range(n)]
    print("List of all students:", all_students)

    # Input for cricket players
    n = int(input("\nEnter the number of students who play cricket: "))
    cricket = [input(f"Enter name of cricket player {i+1}: ") for i in range(n)]
    cricket = remove_duplicate(cricket)
    print("List of cricket players:", cricket)

    # Input for football players
    n = int(input("\nEnter the number of students who play football: "))
    football = [input(f"Enter name of football player {i+1}: ") for i in range(n)]
    football = remove_duplicate(football)
    print("List of football players:", football)

    # Input for badminton players
    n = int(input("\nEnter the number of students who play badminton: "))
    badminton = [input(f"Enter name of badminton player {i+1}: ") for i in range(n)]
    badminton = remove_duplicate(badminton)
    print("List of badminton players:", badminton)

    # Menu
    while True:
        print("\n----- MENU -----")
        print("1. List of students who play both cricket and badminton")
        print("2. List of students who play either cricket or badminton but not both")
        print("3. Number of students who play neither cricket nor badminton")
        print("4. Number of students who play cricket and football but not badminton")
        print("5. Exit")

        choice = int(input("Enter your choice: "))
        if choice == 1:
            print("Number of students:", cricket_and_badminton(cricket, badminton))
        elif choice == 2:
            print("Number of students:", either_cricket_or_badminton(cricket, badminton))
        elif choice == 3:
            print("Number of students:", neither_cricket_nor_badminton(all_students, cricket, badminton))
        elif choice == 4:
            print("Number of students:", cricket_and_football_not_badminton(cricket, football, badminton))
        elif choice == 5:
            print("Thanks for using the program!")
            break
        else:
            print("Invalid choice! Please try again.")

# Execute main function
if __name__ == "__main__":
    main()





####Experiment Number 2 : Write a python program to store marks stored in subject "Fundamentals of
Data Structure" by
N students in the class. Write functions to compute following:
1. The average score of the class.
2. Highest score and lowest score of the class.
3. Count of students who were absent for the test.
4. Display mark with highest frequency.


# Function for average score of the class
def average(listofmarks):
    sum = 0
    count = 0
    for mark in listofmarks:
        if mark != -999:
            sum += mark
            count += 1
    avg = sum / count
    print("Total Marks:", sum)
    print("Average Marks: {:.2f}".format(avg))

# Function for Highest score in the test for the class
def Maximum(listofmarks):
    for mark in listofmarks:
        if mark != -999:
            Max = mark
            break
    for mark in listofmarks:
        if mark > Max and mark != -999:
            Max = mark
    return Max

# Function for Lowest score in the test for the class
def Minimum(listofmarks):
    for mark in listofmarks:
        if mark != -999:
            Min = mark
            break
    for mark in listofmarks:
        if mark < Min and mark != -999:
            Min = mark
    return Min

# Function for counting the number of students absent for the test
def absentcount(listofmarks):
    return listofmarks.count(-999)

# Function for displaying marks with highest frequency
def maxFrequency(listofmarks):
    frequency = {}
    for mark in listofmarks:
        if mark != -999:
            frequency[mark] = frequency.get(mark, 0) + 1
    max_freq = max(frequency.values(), default=0)
    mark = max(frequency, key=frequency.get, default=None)
    print("Marks | Frequency")
    for key, value in frequency.items():
        print(f"{key} | {value}")
    return mark, max_freq

# Main function
if __name__ == "__main__":
    marksinFDS = []
    numberofstudents = int(input("Enter total number of students: "))
    for i in range(numberofstudents):
        marks = int(input(f"Enter marks of student {i + 1}: "))
        marksinFDS.append(marks)

    flag = True
    while flag:
        print("\n\n--------------------MENU--------------------")
        print("1. Total and Average Marks of the Class")
        print("2. Highest and Lowest Marks in the Class")
        print("3. Number of Students Absent for the Test")
        print("4. Marks with Highest Frequency")
        print("5. Exit\n")
        ch = int(input("Enter your Choice (from 1 to 5): "))

        if ch == 1:
            average(marksinFDS)
        elif ch == 2:
            print("Highest Score in Class:", Maximum(marksinFDS))
            print("Lowest Score in Class:", Minimum(marksinFDS))
        elif ch == 3:
            print("Number of Students Absent in the Test:", absentcount(marksinFDS))
        elif ch == 4:
            mark, fr = maxFrequency(marksinFDS)
            print(f"Highest frequency is of marks {mark} that is {fr}")
        elif ch == 5:
            flag = False
            print("Thanks for using this program!")
        else:
            print("!! Wrong Choice !!")




######selection sort and bubble sort


# Function for Selection Sort
def selectionSort(array, size):
    for ind in range(size):
        min_index = ind
        for j in range(ind + 1, size):
            # select the minimum element in every iteration
            if array[j] < array[min_index]:
                min_index = j
        # swapping the elements to sort the array
        array[ind], array[min_index] = array[min_index], array[ind]

# Driver code for selection sort
arr = [-2, 45.7, 0, 11.99, -9, 88.00, -97, -202, 747]
size = len(arr)
selectionSort(arr, size)
print('The array after sorting in Ascending Order by selection sort is:')
print(arr)

# Function for Bubble Sort
def bubbleSort(arr):
    n = len(arr)
    # optimize code, so if the array is already sorted, it doesn't need
    # to go through the entire process
    swapped = False
    # Traverse through all array elements
    for i in range(n-1):
        # range(n) also work but outer loop will repeat one time more than needed.
        # Last i elements are already in place
        for j in range(0, n-i-1):
            # traverse the array from 0 to n-i-1
            # Swap if the element found is greater than the next element
            if arr[j] > arr[j + 1]:
                swapped = True
                arr[j], arr[j + 1] = arr[j + 1], arr[j]
        if not swapped:
            # if we haven't needed to make a single swap, we can just exit the main loop.
            return

# Driver code to test bubble sort
arr = [64, 34, 25, 12, 22, 11, 90]
bubbleSort(arr)
print("Sorted array is:")
for i in range(len(arr)):
    print("% d" % arr[i], end=" ")

# Function for Selection Sort of marks
def Selection_Sort(marks):
    for i in range(len(marks)):
        # Find the minimum element in remaining unsorted array
        min_idx = i
        for j in range(i + 1, len(marks)):
            if marks[min_idx] > marks[j]:
                min_idx = j
        # Swap the minimum element with the first element
        marks[i], marks[min_idx] = marks[min_idx], marks[i]

    print("Marks of students after performing Selection Sort on the list : ")
    for i in range(len(marks)):
        print(marks[i])

# Function for Bubble Sort of marks
def Bubble_Sort(marks):
    n = len(marks)
    # Traverse through all array elements
    for i in range(n - 1):
        # Last i elements are already in place
        for j in range(0, n - i - 1):
            # Traverse the array from 0 to n-i-1
            # Swap if the element found is greater than the next element
            if marks[j] > marks[j + 1]:
                marks[j], marks[j + 1] = marks[j + 1], marks[j]

    print("Marks of students after performing Bubble Sort on the list :")
    for i in range(len(marks)):
        print(marks[i])

# Function for displaying top five marks
def top_five_marks(marks):
    print("Top", len(marks), "Marks are : ")
    print(*marks[::-1], sep="\n")

# Main program
marks = []
n = int(input("Enter number of students whose marks are to be displayed : "))
print("Enter marks for", n, "students (Press ENTER after every student's marks): ")
for i in range(0, n):
    ele = int(input())
    marks.append(ele)  # adding the element

print("The marks of", n, "students are : ")
print(marks)

flag = 1
while flag == 1:
    print("\n---------------MENU---------------")
    print("1. Selection Sort of the marks")
    print("2. Bubble Sort of the marks")
    print("3. Exit")
    ch = int(input("\n\nEnter your choice (from 1 to 3) : "))

    if ch == 1:
        Selection_Sort(marks)
        a = input("\nDo you want to display top marks from the list (yes/no) : ")
        if a == 'yes':
            top_five_marks(marks)
        else:
            print("\nThanks for using this program!")
            flag = 0

    elif ch == 2:
        Bubble_Sort(marks)
        a = input("\nDo you want to display top five marks from the list (yes/no) : ")
        if a == 'yes':
            top_five_marks(marks)
        else:
            print("\nThanks for using this program!")
            flag = 0

    elif ch == 3:
        print("\nThanks for using this program!!")
        flag = 0

    else:
        print("\nEnter a valid choice!!")
        print("\nThanks for using this program!!")
        flag = 0

# Function to print roll numbers
def print_roll(a):
    for i in range(0, len(a)):
        print("\t", a[i], end=" ")
    print()

# <----------------------------------------END OF PROGRAM------------------------------------------------->





#####A palindrome is a string of character that‘s the same forward and backward. Typically, punctuation,
capitalization, and spaces are ignored. For example, “Poor Dan is in a droop” is a palindrome, as can
be seen by examining the characters “poor danisina droop” and observing that they are the same
forward and backward. One way to check for a palindrome is to reverse the characters in the string
and then compare with them the original-in a palindrome, the sequence will be identical. Write C++

program with functions-
a) To print original string followed by reversed string using stack

b) To check whether given string is palindrome or not






#include<iostream>
#include<string.h>
#define max 50
using namespace std;

char a[max];
int tos = -1;

void push(int c)
{
    if (tos == max - 1)
        cout << "Stack is full";
    else
    {
        tos++;
        a[tos] = c;
        a[tos + 1] = '\0';
    }
}

void reverse()
{
    cout << "\nReverse string is : ";
    for (int i = tos; i >= 0; i--)
    {
        cout << a[i];
    }
}

int palindrome()
{
    int i, j;

    // Check if the string is a palindrome
    for (i = tos, j = 0; i >= (tos / 2), j <= (tos / 2); i--, j++)
    {
        if (a[i] != a[j])
            return 0; // Not a palindrome
    }
    return 1; // Is a palindrome
}

int main()
{
    int a;
    int i = 0;
    char str[max];

    cout << "\nEnter string for checking reversed and palindrome : ";
    cin.getline(str, 50);

    while (str[i] != '\0')
    {
        push(str[i]);
        i++;
    }

    a = palindrome();
    if (a == 1)
        cout << "\n\nString is palindrome...";
    else
        cout << "\n\nString is not palindrome...";

    reverse();

    return 0;
}



####Pizza parlor accepting maximum M orders. Orders are served in first come first served basis. Order
once placed cannot be cancelled. Write C++ program to simulate the system using circular queue
using array.



#include<iostream>
using namespace std;

const int MAX = 5;

class PizzaParlour
{
    int front, rear;
    int orders[MAX];
public:
    PizzaParlour()
    {
        front = rear = -1;
    }

    bool addOrder(int data);
    void serveOrder();
    void display();
};

bool PizzaParlour::addOrder(int id)
{
    if (rear == -1)
    {
        front = rear = 0;
        orders[rear] = id;
        return true;
    }
    else
    {
        int pos = (rear + 1) % MAX;
        if (pos == front)
        {
            cout << "\nCafe is Full. Please wait.\n";
            return false;
        }
        else
        {
            rear = pos;
            orders[rear] = id;
            return true;
        }
    }
}

void PizzaParlour::serveOrder()
{
    if (front == -1)
    {
        cout << "\nNo Orders in Cafe. [Cafe is Empty]\n";
        return;
    }
    else
    {
        cout << "\nOrder No. " << orders[front] << " is processed.\n";
        if (front == rear) // Only one order
        {
            front = rear = -1;
        }
        else
        {
            front = (front + 1) % MAX;
        }
    }
}

void PizzaParlour::display()
{
    int i = 0;
    if (front == -1)
    {
        cout << "\nCafe is Empty. No orders.\n";
        return;
    }
    else
    {
        cout << "Order Id's: \n";
        for (i = front; i != rear; i = ((i + 1) % MAX))
        {
            cout << orders[i] << " ";
        }
        cout << orders[rear] << endl;
    }
}

void intro()
{
    char name[50] = {"\n Vaibhav Cafe \n"};
    for (int i = 0; name[i] != '\0'; i++)
    {
        cout << name[i];
    }
}

int main()
{
    int ch, id = 0;
    PizzaParlour q;

    do
    {
        cout << "\n-----------------";
        intro();
        cout << "-----------------";
        cout << "\n****Menu*****\n";
        cout << "1. Accept order\n";
        cout << "2. Serve order\n";
        cout << "3. Display orders\n";
        cout << "4. Exit";

        cout << "\nChoice: ";
        cin >> ch;

        switch (ch)
        {
        case 1:
            id++;
            if (q.addOrder(id))
            {
                cout << "Thank you for the order. Order ID is : " << id << endl;
            }
            else
            {
                id--;
            }
            break;

        case 2:
            q.serveOrder();
            break;

        case 3:
            q.display();
            break;

        }
    } while (ch != 4);

    cout << "\nThank you. Keep Visiting.\n";
}




###A double-ended queue (deque) is a linear list in which additions and deletions may be made at either end. Obtain a data representation mapping a deque into a onedimensional array. Write C++ program to simulate deque with functions to add and delete elements from either end of the deque


#include<iostream>
using namespace std;

#define MAX 5 // Defining the maximum size of the deque

class Deque {
private:
    int arr[MAX];
    int front, rear;

public:
    // Constructor to initialize front and rear pointers
    Deque() {
        front = -1;
        rear = -1;
    }

    // Function to check if the deque is full
    bool isFull() {
        if ((rear + 1) % MAX == front)
            return true;
        return false;
    }

    // Function to check if the deque is empty
    bool isEmpty() {
        if (front == -1)
            return true;
        return false;
    }

    // Function to insert an element at the front
    void insertFront(int data) {
        if (isFull()) {
            cout << "\nDeque is full, cannot insert at front!" << endl;
        } else {
            if (front == -1) {  // If the deque is empty, initialize front and rear to 0
                front = rear = 0;
            } else {
                front = (front - 1 + MAX) % MAX;  // Circular increment for front
            }
            arr[front] = data;  // Add the element at the front
            cout << "Inserted " << data << " at the front" << endl;
        }
    }

    // Function to insert an element at the rear
    void insertRear(int data) {
        if (isFull()) {
            cout << "\nDeque is full, cannot insert at rear!" << endl;
        } else {
            if (front == -1) {  // If the deque is empty, initialize front and rear to 0
                front = rear = 0;
            } else {
                rear = (rear + 1) % MAX;  // Circular increment for rear
            }
            arr[rear] = data;  // Add the element at the rear
            cout << "Inserted " << data << " at the rear" << endl;
        }
    }

    // Function to delete an element from the front
    void deleteFront() {
        if (isEmpty()) {
            cout << "\nDeque is empty, cannot delete from front!" << endl;
        } else {
            cout << "Deleted " << arr[front] << " from the front" << endl;
            if (front == rear) {  // If there is only one element
                front = rear = -1;
            } else {
                front = (front + 1) % MAX;  // Circular increment for front
            }
        }
    }

    // Function to delete an element from the rear
    void deleteRear() {
        if (isEmpty()) {
            cout << "\nDeque is empty, cannot delete from rear!" << endl;
        } else {
            cout << "Deleted " << arr[rear] << " from the rear" << endl;
            if (front == rear) {  // If there is only one element
                front = rear = -1;
            } else {
                rear = (rear - 1 + MAX) % MAX;  // Circular decrement for rear
            }
        }
    }

    // Function to display the deque elements
    void display() {
        if (isEmpty()) {
            cout << "\nDeque is empty!" << endl;
            return;
        }
        cout << "Deque elements: ";
        int i = front;
        while (i != rear) {
            cout << arr[i] << " ";
            i = (i + 1) % MAX;
        }
        cout << arr[rear] << endl;  // Print the last element
    }
};

int main() {
    Deque dq;
    int choice, data;

    do {
        cout << "\n---------------------Menu---------------------";
        cout << "\n1. Insert at Front";
        cout << "\n2. Insert at Rear";
        cout << "\n3. Delete from Front";
        cout << "\n4. Delete from Rear";
        cout << "\n5. Display Deque";
        cout << "\n6. Exit";
        cout << "\n----------------------------------------------";
        cout << "\nEnter your choice: ";
        cin >> choice;

        switch (choice) {
        case 1:
            cout << "\nEnter the element to insert at front: ";
            cin >> data;
            dq.insertFront(data);
            break;
        case 2:
            cout << "\nEnter the element to insert at rear: ";
            cin >> data;
            dq.insertRear(data);
            break;
        case 3:
            dq.deleteFront();
            break;
        case 4:
            dq.deleteRear();
            break;
        case 5:
            dq.display();
            break;
        case 6:
            cout << "\nExiting... Thank you!" << endl;
            break;
        default:
            cout << "\nInvalid choice! Please try again." << endl;
        }
    } while (choice != 6);

    return 0;
}





#### write the python program to sort the array element using selection and bubble sort




def selection_sort(arr):
    n = len(arr)
    for i in range(n):
        min_index = i
        for j in range(i + 1, n):
            if arr[j] < arr[min_index]:
                min_index = j
        arr[i], arr[min_index] = arr[min_index], arr[i]
def bubble_sort(arr):
    n = len(arr)
    for i in range(n):
        swapped = False
        for j in range(0, n-i-1):
            if arr[j] > arr[j+1]:
                arr[j], arr[j+1] = arr[j+1], arr[j]
                swapped = True
        # If no two elements were swapped, the array is sorted
        if not swapped:
            break
def input_percentages():
    n = int(input("Enter the number of students: "))
    percentages = []
    for i in range(n):
        # percent = int(input(f"Enter percentage of student {i + 1}: "))
        print("Enter the percentages of the students: ")
        percent = int(input())
        percentages.append(percent)
    return percentages
def display_percentages(arr):
    print("Sorted percentages in ascending order:")
    for percent in arr:
        print(percent)
def main():
    percentages = input_percentages()
    
    print("Choose the sorting method:")
    print("1. Selection Sort")
    print("2. Bubble Sort")
    choice = input("Enter 1 or 2: ")
    
    if choice == '1':
        selection_sort(percentages)
        print("Using Selection Sort.")
    elif choice == '2':
        bubble_sort(percentages)
        print("Using Bubble Sort.")
    else:
        print("Invalid choice. ")
            
    display_percentages(percentages)
if __name__ == "__main__":
    main()


######Department of Computer Engineering has student's club named 'Pinnacle Club'. Students of second, third and final year of department can be granted membership on request. Similarly one may cancel the membership of club. First node is reserved for president of club and last node is reserved for secretary of club. Write C++ program to maintain club member‘s information using singly linked list. Store student PRN and Name. Write functions to: a) Add and delete the members as well as president or even secretary. b) Compute total number of members of club c) Display members d) Two linked lists exists for two divisions. Concatenate two lists.



#include <iostream>
using namespace std;

struct Node {
    int PRN;
    string Name;
    Node *next;
};

Node *head1 = NULL;
Node *head2 = NULL;

// Function to create a new node and return it
Node* createNode() {
    int prn;
    string name;
    cout << "Enter the PRN no: ";
    cin >> prn;
    cout << "Enter the Name: ";
    cin.ignore();  // Ignore the newline character from previous input
    getline(cin, name);  // Use getline to allow spaces in name
    
    Node *temp = new Node;
    temp->PRN = prn;
    temp->Name = name;
    temp->next = NULL;
    return temp;
}

// Function to print the linked list
void printList(Node *head) {
    cout << "Printing List: ";
    Node *ptr = head;
    while (ptr != NULL) {
        cout << ptr->PRN << " (" << ptr->Name << ") -> ";
        ptr = ptr->next;
    }
    cout << "NULL" << endl;
}

// Function to insert a node at a specific position in the linked list
void insertAtPosition(Node *&head, int position) {
    Node *temp = createNode();
    if (position == 1) {
        temp->next = head;
        head = temp;
        return;
    }

    Node *ptr = head;
    for (int i = 1; i < position - 1 && ptr != NULL; i++) {
        ptr = ptr->next;
    }
    if (ptr == NULL) {
        cout << "Position is out of bounds." << endl;
        delete temp;
    } else {
        temp->next = ptr->next;
        ptr->next = temp;
    }
}

// Function to delete a node at a specific position in the linked list
void deleteAtPosition(Node *&head, int position) {
    if (head == NULL) {
        cout << "List is empty." << endl;
        return;
    }

    if (position == 1) {
        Node *temp = head;
        head = head->next;
        delete temp;
        cout << "Deleted node at position 1." << endl;
        return;
    }

    Node *ptr = head;
    for (int i = 1; i < position - 1 && ptr != NULL; i++) {
        ptr = ptr->next;
    }
    if (ptr == NULL || ptr->next == NULL) {
        cout << "Position is out of bounds." << endl;
    } else {
        Node *temp = ptr->next;
        ptr->next = temp->next;
        delete temp;
        cout << "Deleted node at position " << position << "." << endl;
    }
}

// Function to insert the President (at the beginning)
void insertPresident(Node *&head) {
    cout << "Inserting details of President: " << endl;
    Node *temp = createNode();
    temp->next = head;
    head = temp;
}

// Function to insert the Secretary (at the end)
void insertSecretary(Node *&head) {
    cout << "Inserting details of Secretary: " << endl;
    Node *temp = createNode();
    if (head == NULL) {
        head = temp;
    } else {
        Node *ptr = head;
        while (ptr->next != NULL) {
            ptr = ptr->next;
        }
        ptr->next = temp;
    }
}

// Function to delete the President (first node)
void deletePresident(Node *&head) {
    if (head != NULL) {
        Node *temp = head;
        head = head->next;
        delete temp;
        cout << "President deleted." << endl;
    } else {
        cout << "List is empty." << endl;
    }
}

// Function to delete the Secretary (last node)
void deleteSecretary(Node *&head) {
    if (head == NULL) {
        cout << "List is empty." << endl;
        return;
    }
    if (head->next == NULL) {
        delete head;
        head = NULL;
        cout << "Secretary deleted." << endl;
        return;
    }
    Node *ptr = head;
    while (ptr->next->next != NULL) {
        ptr = ptr->next;
    }
    delete ptr->next;
    ptr->next = NULL;
    cout << "Secretary deleted." << endl;
}

// Function to count the total members in the list
int countMembers(Node *head) {
    int count = 0;
    Node *ptr = head;
    while (ptr != NULL) {
        count++;
        ptr = ptr->next;
    }
    return count;
}

// Function to merge two sorted linked lists
Node* mergeLists(Node* headA, Node* headB) {
    if (headA == NULL) return headB;
    if (headB == NULL) return headA;

    Node *mergedHead = NULL;

    if (headA->PRN <= headB->PRN) {
        mergedHead = headA;
        headA = headA->next;
    } else {
        mergedHead = headB;
        headB = headB->next;
    }

    Node *mergedTail = mergedHead;

    while (headA != NULL && headB != NULL) {
        if (headA->PRN <= headB->PRN) {
            mergedTail->next = headA;
            headA = headA->next;
        } else {
            mergedTail->next = headB;
            headB = headB->next;
        }
        mergedTail = mergedTail->next;
    }

    if (headA != NULL) {
        mergedTail->next = headA;
    } else {
        mergedTail->next = headB;
    }

    return mergedHead;
}

int main() {
    int ch1, ch2, position;
    bool choice = true;

    while (choice) {
        cout << "1. Insert\n2. Delete\n3. Count Members\n4. Display Members\n5. Merge Lists\n6. Exit" << endl;
        cin >> ch1;

        switch (ch1) {
            case 1: {
                bool choice1 = true;
                while (choice1) {
                    cout << "1. President (List 1)\n2. Secretary (List 1)\n3. Insert at Position (List 1)\n4. President (List 2)\n5. Secretary (List 2)\n6. Insert at Position (List 2)\n7. Exit" << endl;
                    cin >> ch2;

                    switch (ch2) {
                        case 1:
                            insertPresident(head1);
                            break;
                        case 2:
                            insertSecretary(head1);
                            break;
                        case 3:
                            cout << "Enter position to insert in List 1: ";
                            cin >> position;
                            insertAtPosition(head1, position);
                            break;
                        case 4:
                            insertPresident(head2);
                            break;
                        case 5:
                            insertSecretary(head2);
                            break;
                        case 6:
                            cout << "Enter position to insert in List 2: ";
                            cin >> position;
                            insertAtPosition(head2, position);
                            break;
                        case 7:
                            choice1 = false;
                            break;
                        default:
                            cout << "Invalid choice. Try again." << endl;
                    }
                }
                break;
            }
            case 2: {
                bool choice2 = true;
                while (choice2) {
                    cout << "1. Delete President (List 1)\n2. Delete Secretary (List 1)\n3. Delete at Position (List 1)\n4. Exit" << endl;
                    cin >> ch2;

                    switch (ch2) {
                        case 1:
                            deletePresident(head1);
                            break;
                        case 2:
                            deleteSecretary(head1);
                            break;
                        case 3:
                            cout << "Enter position to delete from List 1: ";
                            cin >> position;
                            deleteAtPosition(head1, position);
                            break;
                        case 4:
                            choice2 = false;
                            break;
                        default:
                            cout << "Invalid choice. Try again." << endl;
                    }
                }
                break;
            }
            case 3: {
                cout << "Total members in List 1: " << countMembers(head1) << endl;
                cout << "Total members in List 2: " << countMembers(head2) << endl;
                break;
            }
            case 4: {
                cout << "Members of List 1:" << endl;
                printList(head1);
                cout << "Members of List 2:" << endl;
                printList(head2);
                break;
            }
            case 5: {
                Node* mergedList = mergeLists(head1, head2);
                cout << "Merged List:" << endl;
                printList(mergedList);
                break;
            }
            case 6:
                choice = false;
                break;
            default:
                cout << "Invalid choice. Try again." << endl;
        }
    }

    return 0;
}





